# STL 部分

本篇都是关于 STL 的部分

## 1. `std::list` 和 `std::vector` 有什么区别

- 内存分配方式和存储方式
    - `std::vector` 内部使用连续的内存块来存储元素
    - `std::list` 内部用双向链表来存储元素
- 元素访问
    - `std::vector` 支持随机访问，即可以通过索引直接访问任何元素。访问特定位置元素的时间复杂度是 $O(1)$
    - `std::list` 不支持随机访问，只能通过迭代器顺序遍历元素。访问特定位置元素的时间复杂度是 $O(n)$
- 插入和删除
    - `std::vector`
        - 在尾部插入或删除元素的时间复杂度都是 $O(1)$
        - 在中间或头部插入和删除元素的时间复杂度是 O(n)，因为需要移动其他元素
    - `std::list`
        - 在任何位置插入和删除元素的时间复杂度都是 O(1)（给定迭代器指向要插入/删除的位置）

## 2. `std::vector` 的 `size()` 和 `capacity()` 函数都是什么

`size()` 返回了该 vector 已用空间的大小，而 `capacity()` 返回的是该 vector 预先分配的存储空间的大小（即 vector 在不重新分配内存的前提下能存储多少数据）

使用 `resize()` 可以改变当前 vector 的 size，属于修改

- 如果 `resize(n)` 的 `n == size()`，那就什么也不做
- 如果 `resize(n)` 的 `n < size()`，就减少当前 vector 的元素
- 如果 `resize(n)` 的 `n > size()`，追加默认数据到当前 vector 的末尾处
    - `resize()` 存在一个重载 `void resize( size_type count, const value_type& value );`，这种会把 `value` 添加到末尾

使用 `reverse()` 可以改变当前 vector 的 capacity，但不会修改数据

`reverse(n)` 会把 vector 的 capacity 增加到大于等于 `n` 的值。如果 `n` 大于当前的 `capacity()` 就重新分配该 vector，如果不是就什么也不做

`reverse()` 不可被用于减少容量，提供该功能的是 `shrink_to_fit()`

## 3. `std::set` 和 `std::map` 都是怎么实现的

- `std::map` 是一个有序键值对容器，使用红黑树实现
- `std::set` 是一个有序唯一元素集合，它通常也使用红黑树实现

红黑树是一种自平衡二叉搜索树，它保证了在最坏情况下，查找、插入和删除操作的时间复杂度都是 $O(log n)$

红黑树的有序性使得 std::map 和 std::set 可以方便地进行有序遍历和范围查找

## 4. `std::unordered_map` 是什么，它是如何解决哈希冲突问题的

`std::unordered_map` 是 C++ 标准库中的一个关联容器，它提供了一种基于哈希表实现的键值对存储方式。与 `std::map` 相比，`std::unordered_map` 中的元素没有特定的顺序，但它提供了平均常数时间复杂度的查找、插入和删除操作

哈希表通过哈希函数将键映射到存储桶（bucket）中，从而实现快速查找

在理想情况下（哈希函数分布均匀，没有或很少有哈希冲突），`std::unordered_map` 的查找、插入和删除操作的时间复杂度为 `O(1)`

**哈希冲突及解决方案**

当两个或多个不同的键被哈希函数映射到同一个存储桶时，就会发生哈希冲突

解决方案:

- 链地址法 (Separate Chaining)
    - 每个存储桶存储一个链表，当发生哈希冲突时，新的键值对会被添加到链表的末尾
    - 查找时，先通过哈希函数找到对应的存储桶，然后遍历链表查找目标键
- 开放寻址法 (Open Addressing)
    - 当发生哈希冲突时，在哈希表中寻找下一个可用的空闲位置来存储新的键值对
    - 查找时，如果找到的存储桶中的键不匹配，则按照一定的规则（例如，线性探测、二次探测）继续查找

STL 中，`std::unordered_map` 使用链地址法解决该问题
