# 网络部分

## 1. 了解 IO 多路复用吗，`epoll` 和 `select` 的区别是什么

IO 多路复用是指在单个线程中同时监视多个 IO 事件（例如读取、写入等），从而提高系统的并发处理能力，避免因线程/进程阻塞而导致的性能瓶颈。IO 多路复用常见的实现方式有 `select`、`poll` 和 `epoll` 等。

> `select` 是一种 I/O 多路复用机制，它可以让一个进程同时监控多个文件描述符，判断这些文件描述符是否可以进行读取、写入或是否有异常发生。`select` 的工作原理是将一组文件描述符传给内核，内核会检查这些文件描述符的状态，并返回可以操作的文件描述符集合。
>
> `poll` 是 `select` 的改进版，允许同时监听多个文件描述符，但仍然存在一些性能瓶颈。类似于 `select`，但没有 `select` 那样 `FD_SETSIZE` 的限制，结构更加直观，不需要像 `select` 那样填充 fd_set，可以直接操作 `pollfd` 结构体。
>
> `epoll` 是 Linux 提供的一种 I/O 多路复用机制，它是为了克服 `select` 的性能瓶颈而设计的。`epoll` 采用了事件驱动的方式，只有当文件描述符有事件发生时，内核才会通知用户进程，大大提高了效率，特别是在大量文件描述符的情况下。

差别：

**性能差距**

- `select` 的效率较低，尤其在监控的文件描述符数量较多时。它的缺点是每次调用时都需要将所有的文件描述符从用户空间拷贝到内核空间，检查是否有事件发生，然后再将结果拷贝回用户空间。文件描述符数量超过一定量时，性能下降显著（通常超过 1024 个文件描述符）。
- `epoll` 是 Linux 下为了解决 `select` 的性能瓶颈而设计的，它采用了基于事件的通知机制，不需要每次都遍历所有的文件描述符。它的性能随着文件描述符数量的增加而提高，适合高并发环境。

**支持的文件描述符数量**

- `select` 有一个最大文件描述符限制，通常是 1024（可以通过修改 `FD_SETSIZE` 来调整，但这不是非常灵活）。
- `epoll` 没有这个限制，支持的文件描述符数量是理论上无限制的，取决于操作系统的资源限制。

**调用方式**

- `select`: `select` 每次调用时都会把所有的文件描述符都传递给内核，内核会返回哪些文件描述符可以进行读写。它是轮询式的。
- `epoll`: `epoll` 则采用了事件驱动模型，它通过 `epoll_ctl` 添加或者删除文件描述符，而通过 `epoll_wait` 来等待有事件的文件描述符。`epoll` 会在内核空间维护一个文件描述符的列表，只有事件发生时，才会通知用户空间，避免了 `select` 中每次都要传递所有文件描述符的问题。

## 2. 什么是零拷贝

零拷贝是指在数据传输过程中减少 CPU 介入、减少数据拷贝次数，提高 I/O 性能。

在传统的 I/O 读写模型中，数据需要在内核空间和用户空间之间拷贝多次，导致 CPU 开销大，缓存污染严重。

**传统数据拷贝的缺点**

在传统的 `read()` 和 `write()` 方式下，数据传输流程如下

1. `read(fd, buf, size)`
    - DMA 从磁盘读取数据到内核缓冲区
    - CPU 拷贝数据到用户空间的 buf
2. `write(fd, buf, size)`
    - CPU 拷贝 数据从用户空间 的 buf 到内核缓冲区
    - DMA 传输数据到网卡，发送给远端
- `磁盘 ->(DMA) 内核缓冲区 ->(CPU) 用户空间 ->(CPU) Socket 缓冲区 ->(DMA) 网卡`

这里总共发生了四次数据拷贝，效率慢

**零拷贝的方式**

- `sendfile`
    - `sendfile()` 用于直接在文件描述符之间传输数据，避免用户空间拷贝
    - `磁盘 ->(DMA) 内核缓冲区 ->(CPU) Socket 缓冲区 ->(DMA) 网卡`
    - 减少了一次 CPU 介入的数据拷贝。适合大文件传输，不适合修改数据的场景
- `mmap` + `write`
    - `mmap()` 允许用户空间直接映射文件，减少 `read()` 带来的 CPU 复制开销。
    - `mmap()` 让用户进程直接访问内核文件缓冲区: `磁盘 ->(DMA) 内核缓冲区 ->(共享) 用户进程`
    - 之后调用 `write(socket, buf, size)` 发送数据: `用户空间（映射数据）->(CPU) Socket 缓冲区 ->(DMA) 网卡`
    - 绕过了 `read()`，减少了数据拷贝的次数。适合随机读取数据，不适合连续传输（因为 `write()` 仍需要拷贝到 socket）
- `splice`
    - `splice()` 允许两个文件描述符之间直接传输数据，完全绕开用户空间，更进一步优化性能。
    - `splice(fd_in, NULL, fd_out, NULL, size, SPLICE_F_MOVE)`
        - 直接在文件描述符之间移动数据，无需拷贝到用户空间
        - 适用于管道与 socket 之间的传输
    - `磁盘 ->(DMA) 内核缓冲区 ->(内核) Socket 缓冲区 ->(DMA) 网卡`
    - 适合文件描述符之间的数据传输，不适合用户态的数据处理

- `splice` 完全绕过了用户空间，甚至避免了 CPU 在内核态拷贝数据，进一步优化性能
- `mmap` 只优化了 `read`，但仍然需要 `write`，所以不如效率 `splice`

## 3. 什么是 DMA

DMA 允许外设（如网卡、磁盘）直接访问内存，而不经过 CPU，从而减少 CPU 负担，加速数据传输

传统的数据传输会是这样:

```txt
设备 ->(CPU 读取) -> CPU 处理 ->(CPU 写入) -> 内存
```

而使用了 DMA 就会是:

```txt
设备 ->(DMA 控制器) -> 内存
```

CPU 只需要启动 DMA 传输，之后就处理其他任务，DMA 直接在设备和内存之间移动数据

- Scatter-Gather DMA
    - 传统 DMA 一次只能传输连续的内存块，但实际应用中数据可能是不连续的，Scatter-Gather DMA 直接将多个块发送到内存，不需要 CPU 组装数据，提高效率
- IOMMU + DMA
    - 在虚拟化和安全场景下，DMA 需要访问不同进程的内存，但传统 DMA 只能访问物理内存
    - IOMMU（I/O Memory Management Unit） 允许 DMA 访问虚拟内存，提高数据安全性，同时支持设备直通（如 PCIe 直通）
