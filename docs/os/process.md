# 进程部分

该部分存放有关进程和线程的题目，如果后续我遇到这部分的题多了，可能分一个线程出去

## 1. 进程和线程之间的区别

- 进程是操作系统进行资源分配和调度的基本单位。它是一个正在运行的程序的实例，拥有独立的内存空间和系统资源。而线程则是进程在执行中的最小单元。
- 进程拥有独立的地址空间和系统资源，而线程间会共享所属进程的地址空间和系统资源。
- 进程的创建，销毁和切换所需要的代价都比线程大
- 进程间的通信需要依靠管道、消息队列、共享内存等方式实现，而线程间的通信并不需要这么复杂

## 2. 线程崩溃是否会影响到进程

会，因为线程本身就是进程一部分，线程崩溃的原因就是进程在执行时遇到了一个运行时的错误，导致进程也崩溃。就算线程的崩溃并不是因为严重的运行时错误，那也很有可能导致共享数据被破坏，从而影响到其他线程的运行。

## 3. Linux 中，僵尸进程、孤儿进程和守护进程都是什么

- 僵尸进程 (Zombie Process)
    - 当一个子进程完成其执行并终止时，它会向其父进程发送一个终止信号。
    - 如果父进程没有调用 `wait()` 或 `waitpid()` 系统调用来获取子进程的终止状态信息，那么子进程的进程描述符仍然会保留在系统中，直到父进程获取为止。
    - 此时，这个已终止但其描述符仍然存在的子进程就被称为僵尸进程。
    - 理想情况下，父进程应该及时调用 `wait()` 或 `waitpid()` 来回收子进程的资源。
    - 如果父进程已经无，init 进程会自动接管僵尸进程，并回收他们。
- 孤儿进程（Orphan Process）
    - 当一个父进程在子进程之前终止时，子进程就会变成孤儿进程。
    - Linux 内核会自动将孤儿进程的父进程设置为 init 进程
- 守护进程（Daemon Process）
    - 守护进程是在后台运行且不与任何终端关联的进程。
    - 它们通常在系统启动时启动，并在系统关闭时终止。

## 4. 如何解决僵尸进程和孤儿进程

### 僵尸进程

**父进程调用 `wait()`**

这是理想方案，程序在代码编写的时候就应该这么做，从而让父进程得以回收资源

**处理 SIGCHLD 信号**

这是因为在子进程退出时，操作系统会向父进程发送 SIGCHLD 信号，父进程可以设置一个信号处理程序来绑定这个信号，从而在捕获到信号后就调用 `wait()`

### 孤儿进程

一般来说，init 进程会负责回收它们。可以使用 `ps 或 pgrep` 查询，并使用 `kill` 终止。

## 5. 内核态和用户态之间是如何切换的，通过了什么方式

切换的原因一般是：

- 系统调用
- 中断
- 异常

切换过程：

- 保存上下文
- 切换模式
- 执行相关操作
- 恢复上下文

> 不得不介绍一下我知道的 RISC-V 中关于内核态和用户态之间切换的东西了
>
> 在 RISC-V 架构中，在用户态模式下运行的时候，用户态会因为程序调用了系统调用，遇到了中断或者异常的原因从而切换到内核态。这里把这三种情况统称为 trap，操作系统内核拥有一段 trap 处理程序以处理这些情况，这个处理程序的地址被写在了 `stvec` 寄存器中。
>
> 等跳到了这里，就需要先保存一下上下文，因为后续还需要恢复，操作系统内核保证了 trap 的处理对用户程序是透明的。在保存了上下文后，内核就会开始读取 `scause` 寄存器的值，因为这个寄存器保存了调用 trap 处理程序的原因，具体值对应的什么可以看 RISC-V ISA 手册

## 6. 线程五种状态及其状态转化条件

1. 新建
    - 此时线程已经创建，但还没有调用 `start()`，调用后即可进入就绪状态
2. 就绪
    - 线程准备好运行，等待 CPU 调度
3. 运行
    - 线程运行中，主动释放CPU资源，进入就绪状态
    - 线程运行中，遇到阻塞事件，进入阻塞状态
4. 阻塞
    - 线程暂停执行，等待某些事件发生（例如，等待 I/O 操作完成、等待锁、等待其他线程通知）
    - 线程调用 wait()、join()、sleep() 等方法可以进入阻塞状态
5. 终止
    - 线程执行完毕或发生异常，结束生命周期

## 7. 线程是谁调度的，线程是怎么生成的

**线程调度**

- 内核线程
    - 由操作系统内核的线程调度器负责线程调度
- 用户线程
    - 线程库自己负责调度，不依赖内核，比如 pthread、Go 语言的 goroutine 调度器

**线程生成**

使用 pthread 创建线程

```c
#include <pthread.h>
#include <stdio.h>

void* thread_func(void* arg) {
    printf("新线程运行中\n");
    return NULL;
}

int main() {
    pthread_t tid;
    pthread_create(&tid, NULL, thread_func, NULL);
    pthread_join(tid, NULL);
    return 0;
}
```

其内部调用 `clone()` 系统调用创建共享内存空间的线程

## 8. 线程和协程有什么区别

|特性|线程|协程|
|:--|:--|:--|
|调度方式|由操作系统（OS）内核调度|由用户态代码调度（用户态线程）|
|切换开销|线程切换涉及上下文切换（需要内核态/用户态切换）|协程切换仅涉及寄存器和栈切换，开销小|
|并行性|线程可以真正并行执行（如果有多个CPU核心）|协程是协作式调度，在单线程中交替执行，不是真正的并行|
|共享资源|线程间共享地址空间，需要加锁防止竞争|协程通常运行在单线程中，避免了数据竞争|
|使用场景|适用于CPU密集型、多核并行计算任务|适用于IO密集型任务，如网络请求、文件读写等|

## 9. 进程间通信的方式

- 管道：匿名管道 `pipe()`，命名管道（FIFO） `mkfifo()`
    - 匿名管道是单向的、进程间通信的数据通道，通常用于父子进程之间的通信
    - 有名管道是命名的管道文件，可以用于无亲缘关系进程之间的通信
- 消息队列：`msgget()`、`msgsnd()`、`msgrcv()`
    - 基于消息的进程间通信机制，允许多对多通信，比管道更灵活
    - 无阻塞特性：可以选择阻塞或非阻塞模式
    - 持久性：进程退出后，队列数据仍可用（除非删除）
- 共享内存：`shmget()`、`shmat()`、`shmdt()`
    - 最快的进程间通信方式，允许多个进程映射到同一个内存区域，从而直接读写数据
    - 进程间同步需额外处理：共享内存本身不提供同步机制，需使用信号量或互斥锁
- 信号：`kill()`、`sigaction()`、`raise()`
    - 异步进程通信机制，主要用于进程间通知，比如进程终止、暂停、恢复等
    - 轻量级：内核发送信号，无需进程轮询
    - 常用于进程控制：如 `SIGKILL` 终止进程，`SIGSTOP` 暂停进程
- 套接字：本地 `AF_UNIX` 或网络 `AF_INET` 套接字
    - 最通用的进程间通信机制，支持本地（Unix 域）和网络（TCP/UDP）通信，适用于分布式系统
    - 支持面向连接（TCP）和无连接（UDP）：灵活选择可靠性或性能
    - 可用于高并发服务器：结合 `epoll` 或 `select` 处理多个连接
- 文件映射：`mmap()`


