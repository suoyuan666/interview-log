# 进程部分

该部分存放有关进程和线程的题目，如果后续我遇到这部分的题多了，可能分一个线程出去

## 1. 进程和线程之间的区别

- 进程是操作系统进行资源分配和调度的基本单位。它是一个正在运行的程序的实例，拥有独立的内存空间和系统资源。而线程则是进程在执行中的最小单元。
- 进程拥有独立的地址空间和系统资源，而线程间会共享所属进程的地址空间和系统资源。
- 进程的创建，销毁和切换所需要的代价都比线程大
- 进程间的通信需要依靠管道、消息队列、共享内存等方式实现，而线程间的通信并不需要这么复杂

## 2. 线程崩溃是否会影响到进程

会，因为线程本身就是进程一部分，线程崩溃的原因就是进程在执行时遇到了一个运行时的错误，导致进程也崩溃。就算线程的崩溃并不是因为严重的运行时错误，那也很有可能导致共享数据被破坏，从而影响到其他线程的运行。

## 3. Linux 中，僵尸进程、孤儿进程和守护进程都是什么

- 僵尸进程 (Zombie Process)
    - 当一个子进程完成其执行并终止时，它会向其父进程发送一个终止信号。
    - 如果父进程没有调用 `wait()` 或 `waitpid()` 系统调用来获取子进程的终止状态信息，那么子进程的进程描述符仍然会保留在系统中，直到父进程获取为止。
    - 此时，这个已终止但其描述符仍然存在的子进程就被称为僵尸进程。
    - 理想情况下，父进程应该及时调用 `wait()` 或 `waitpid()` 来回收子进程的资源。
    - 如果父进程已经无，init 进程会自动接管僵尸进程，并回收他们。
- 孤儿进程（Orphan Process）
    - 当一个父进程在子进程之前终止时，子进程就会变成孤儿进程。
    - Linux 内核会自动将孤儿进程的父进程设置为 init 进程
- 守护进程（Daemon Process）
    - 守护进程是在后台运行且不与任何终端关联的进程。
    - 它们通常在系统启动时启动，并在系统关闭时终止。

## 4. 如何解决僵尸进程和孤儿进程

### 僵尸进程

**父进程调用 `wait()`**

这是理想方案，程序在代码编写的时候就应该这么做，从而让父进程得以回收资源

**处理 SIGCHLD 信号**

这是因为在子进程退出时，操作系统会向父进程发送 SIGCHLD 信号，父进程可以设置一个信号处理程序来绑定这个信号，从而在捕获到信号后就调用 `wait()`

### 孤儿进程

一般来说，init 进程会负责回收它们。可以使用 `ps 或 pgrep` 查询，并使用 `kill` 终止。

## 5. 内核态和用户态之间是如何切换的，通过了什么方式

切换的原因一般是：

- 系统调用
- 中断
- 异常

切换过程：

- 保存上下文
- 切换模式
- 执行相关操作
- 恢复上下文

> 不得不介绍一下我知道的 RISC-V 中关于内核态和用户态之间切换的东西了
>
> 在 RISC-V 架构中，在用户态模式下运行的时候，用户态会因为程序调用了系统调用，遇到了中断或者异常的原因从而切换到内核态。这里把这三种情况统称为 trap，操作系统内核拥有一段 trap 处理程序以处理这些情况，这个处理程序的地址被写在了 `stvec` 寄存器中。
>
> 等跳到了这里，就需要先保存一下上下文，因为后续还需要恢复，操作系统内核保证了 trap 的处理对用户程序是透明的。在保存了上下文后，内核就会开始读取 `scause` 寄存器的值，因为这个寄存器保存了调用 trap 处理程序的原因，具体值对应的什么可以看 RISC-V ISA 手册
