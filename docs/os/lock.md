# 锁的部分

这里说的是并发时候用到的锁

## 1. 死锁产生条件

- 互斥条件
    - 资源必须处于非共享模式，即一次只有一个进程可以使用一个资源。
    - 如果其他进程请求该资源，则请求进程必须等待直到该资源被释放。
- 请求与保持条件
    - 进程至少保持一个资源，并且正在请求由其他进程保持的额外资源
    - 也就是说，进程在等待其他资源的同时，不释放已占有的资源。
- 不剥夺条件
    - 资源只能由进程在完成任务后自愿释放，而不能被强制剥夺。
    - 也就是说，一个进程不能强行夺取其他进程已占有的资源。
- 循环等待条件
    - 存在一组等待进程 {P1, P2, ..., Pn}，其中 P1 等待 P2 占用的资源，P2 等待 P3 占用的资源，依此类推，直到 Pn 等待 P1 占用的资源
    - 形成一个进程等待资源的环形链

## 2. 如何避免死锁

- 破坏请求与保持条件
    - 要求进程在开始执行前一次性申请所有需要的资源，或者允许进程在需要新资源时释放已占有的资源。
- 破坏不剥夺条件
    - 如果进程请求的资源被其他进程占用，则可以剥夺该占用进程的资源。
    - 只有在可以安全地剥夺资源的情况下才能使用此方法。
- 破坏循环等待条件
    - 对所有资源进行排序，并要求进程按顺序申请资源。

## 3. 锁的种类

1. 互斥锁和自旋锁
    - 当已经有一个线程拿到锁后，其他线程获取锁则就会失败，但自旋锁和互斥锁对获取锁失败的处理并不同
    - 互斥锁加锁失败后，线程会释放 CPU ，给其他线程
    - 自旋锁加锁失败后，线程会等待，直到它拿到锁
2. 读写锁
    - 由读锁和写锁组成，如果对共享资源进行 load 操作，就使用读锁，如果是 store，就用写锁
    - 在写锁没有被持有时
        - 读锁可以被多个线程获取，因为这不会导致该数据被修改
    - 当写锁被一个线程持有
        - 其他线程的读和写都不能进行
    - 分为两种实现
        - 读优先
            - 假设 A 线程持有了读锁，那么 B 线程准备持有写锁的时候就会被阻塞，而其他线程可以继续持有读锁。直到所有持有读锁的线程都不再持有它，B 线程才可以持有写锁
        - 写优先
            - 假设 A 线程持有了读锁，那么 B 线程准备持有写锁的时候就会被阻塞，并且其他线程不可以持有读锁。B 线程需要等到 A 线程不再持有读锁时才能持有写锁
    - 上述两种方式都存在获取写锁或者获取读锁的线程会被阻塞很久的可能，可以使用队列按照先进先出的原则处理读线程和写线程
3. 条件变量
    - 用于线程间的同步，线程可以在条件满足前进入等待状态，而不是忙等待消耗 CPU
4. 信号量
    - 控制可同时访问资源的线程数量，可用于实现生产者-消费者模型
4. 乐观锁和悲观锁
    - 上述锁都属于悲观锁，悲观锁认为多线程并发运行时容易出现数据竞争问题，所以访问前需要加锁
    - 乐观锁认为并发时不容易出现并发问题，等操作完再验证出没出问题，比如无锁编程
