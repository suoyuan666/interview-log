# 网络层部分

## 1. TCP 和 UDP 的区别，哪个是面向流的

- 连接
    - TCP
        - 是面向连接的协议。这意味着在数据传输之前，发送方和接收方必须先建立一个连接（通过三次握手）。
        - 一旦连接建立，数据就可以在两个端点之间双向流动。
        - 连接的建立和维护增加了开销，但也确保了数据的可靠传输。
    - UDP
        - 是无连接的协议。发送方在发送数据之前不需要与接收方建立连接。
        - 数据以数据报的形式发送，每个数据报都是一个独立的实体。
        - 由于没有连接建立和维护的开销，UDP传输速度更快。
- 可靠性
    - TCP
        - 提供可靠的数据传输。它通过序列号、确认应答和重传机制来确保数据包按顺序、无错误地到达目的地。
        - 如果数据包丢失或损坏，TCP会重新发送它们。
        - TCP还提供流量控制，以防止发送方发送过多数据而使接收方不堪重负。
    - UDP
        - 不提供可靠的数据传输。它只是尽力而为地发送数据包，但不保证它们一定能到达目的地，也不保证它们的顺序。
        - UDP没有错误检测或重传机制。
        - 因此，UDP传输的数据可能会丢失、损坏或乱序。
- 传输方式
    - TCP
        - 是面向字节流的协议。它将应用程序发送的数据视为一个连续的字节流，并将其分割成较小的段进行传输。
        - 接收方将这些段重新组装成原始的字节流。
    - UDP
        - 是面向报文的协议。它将应用程序发送的数据视为一个独立的数据报，并将其作为一个整体进行传输。
        - 接收方接收到的也是一个个独立的数据报。

## 2. TCP 的拥塞控制

TCP 拥塞控制主要用于解决网络中因数据包过多而导致的丢包和延迟问题。它的核心目标是在保证网络吞吐量的同时，避免因过载导致的性能下降。

1. 慢启动（Slow Start）
    - 发送方在连接建立后，会将拥塞窗口（cwnd）初始化为一个较小的值，通常是 1 MSS（最大报文段）。
    - 每收到一个 ACK，拥塞窗口成倍增长（指数增长）。
    - 直到 cwnd 达到慢启动阈值（ssthresh）或出现丢包。
2. 拥塞避免（Congestion Avoidance）
    - 当 cwnd ≥ ssthresh 时，进入拥塞避免阶段。
    - 此时不再指数增长，而是线性增长（每经过一个 RTT，cwnd 增加大约 1 MSS）。
    - 防止过快增长导致网络拥塞。
3.  快速重传（Fast Retransmit）
    - 当接收方发现有数据包丢失时，会连续发送三个相同的 ACK（即 DUPACK）。
    - 发送方在收到三个重复 ACK 后，立即重传丢失的数据包，而不需要等到超时。
4. 快速恢复（Fast Recovery）
    - 快速重传后，发送方认为当前网络并未完全拥塞，仅是局部丢包。
    - 将 ssthresh 设为 cwnd 的一半，并将 cwnd 直接设置为 ssthresh，避免退回到慢启动的初始值。
    - 之后 cwnd 按照拥塞避免的线性方式增长。

> 上述四个算法结合是经典的实现方式，现代的拥塞控制并不完全是这么做的。

## 3. 超时重传如何计算 RTO（Retransmission Timeout）

网络的 RTT（Round-Trip Time）是不稳定的，RTO 不能直接用 RTT，而是用平滑的估计。

TCP 采用 加权平均法 平滑 RTT，并计算 RTT 的波动，来决定合适的 RTO。

**经典算法**

- EstimatedRTT: 平滑的 RTT 估计
    - $EstimatedRTT = (1 - α) * EstimatedRTT + α * SampleRTT$
    - $α$ 通常取 $\frac{1}{8}$
- DevRTT: RTT 的偏差（波动范围）
    - $ DevRTT = (1 - β) * DevRTT + β * |SampleRTT - EstimatedRTT|$
    - $β$ 通常取 $\frac{1}{4}$
- RTO 计算
    - $RTO = EstimatedRTT + 4 * DevRTT$

这里的乘 4 是为了保证即使在 RTT 波动大的情况下，RTO 也能保持在合理范围，减少不必要的重传。

## 4. 滑动窗口原理

> 滑动窗口是 TCP 用于实现 流量控制 和 提高链路利用率 的核心机制。

- 发送方根据 Window = min(接收窗口, 拥塞窗口) 确定实际窗口大小。
- 发送方可连续发送 Window 个数据量的报文，而不必等每个 ACK 回来。
- 当收到 ACK 时，窗口右移（即“滑动”），允许继续发送新的数据。
- 接收方通过 ACK 的窗口广告字段，动态告知剩余的接收缓存空间。

## 5. 介绍一下 TCP 的四次挥手，四次可以改成三次吗

- 第一次挥手
    - 主动关闭方（Client）发送 FIN，表示自己没有数据要发了，但仍可接收数据。
    - 状态变为：`FIN_WAIT_1`
- 第二次挥手
    - 被动关闭方（Server）收到 FIN，立即回复 ACK，确认接收到关闭请求。
    - 状态变为：`CLOSE_WAIT`
- 第三次挥手
    - 被动关闭方（Server）处理完剩下的业务后，发送 FIN，表示自己也没有数据要发了。
    - 状态变为：`LAST_ACK`
- 第四次挥手
    - 主动关闭方（Client）收到 FIN 后，回复 ACK，确认连接关闭。
    - 状态变为：`TIME_WAIT`
    - 等待 2MSL（最大报文寿命）后，彻底关闭。

如果被动关闭连接的那一方**没有数据要发送**并且**开启了 TCP 延迟确认机制**，ACK 和 FIN 可能会被合并到同一个包中，表现为只需要三次报文

> TCP 的延迟确认机制是为了解决 ACK 的传输效率问题。该机制默认开启。当有数据要发送时，ACK 会随数据一起发送。无数据发送的话，就等一段时间，看看是否会等到要发送数据。但如果等待的时候对方又有数据包到达，就会立刻发送 ACK。
